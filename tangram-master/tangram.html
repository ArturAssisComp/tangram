<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Tangram</title>
		<style>
			body { margin: 0;}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
            //A scenario must have a scene, a camera, and a renderer 
            const scene = new THREE.Scene();
            width=window.innerWidth;
            height=window.innerHeight;
            const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, -1000, 1000 );
            scene.add( camera );

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor(0xFFFFFF,1);
            document.body.appendChild( renderer.domElement );
            //-------

            //Materials and colors 
            const highlighted               = new THREE.MeshBasicMaterial( { color: 0xfff000 } );
            const material_red              = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
            const material_blue             = new THREE.MeshBasicMaterial( { color: 0x0000fff} );
            const material_black            = new THREE.MeshBasicMaterial( { color: 0x000000 } );
            const material_green            = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            const material_orange           = new THREE.MeshBasicMaterial( { color: 0xffa500} );
            const material_yellow           = new THREE.MeshBasicMaterial( { color: 0xffff00} );
            const material_light_blue       = new THREE.MeshBasicMaterial( { color: 0x00aafff} );
            const material_ligth_blue_green = new THREE.MeshBasicMaterial( { color: 0x007777 } );


            //-------

            //Creating background 
            const L = 500
            const initial_position = new THREE.Vector2(100, -250);
            
            const geometry_background = new THREE.BufferGeometry();
            // BufferGeometry is composed by multiple triangles.
            var background_vertices = new Float32Array([
                            0, 0, 0,
                            L, 0, 0,
                            L, L, 0,

                            L, L, 0,
                            0, L, 0,
                            0, 0, 0
                        ]);
            geometry_background.setAttribute('position', new THREE.BufferAttribute(background_vertices, 3));
                
            const background = new THREE.Mesh( geometry_background, material_black );

            scene.add( background );

            background.position.set(initial_position.x, initial_position.y, -10)
            //-------

            //Creating scene objects
            const offset = 550
            var x_mean;
            var y_mean;
            /*Object A*/
            x_mean = L/6;
            y_mean = L/2;;
            var geometry_A = new THREE.BufferGeometry();
            var vertices_A = new Float32Array([
                            0 - x_mean,   0 - y_mean,   0,
                            L/2 - x_mean, L/2 - y_mean, 0,
                            0 - x_mean,   L - y_mean,   0
                        ]);
            geometry_A.setAttribute('position', new THREE.BufferAttribute(vertices_A, 3));
                
            var A = new THREE.Mesh( geometry_A, material_ligth_blue_green);

            scene.add( A );

            A.position.set(initial_position.x - offset, initial_position.y + 50, -1)

            /*Object B*/
            x_mean = L/2;
            y_mean = 5*L/6;;
            var geometry_B = new THREE.BufferGeometry();
            var vertices_B = new Float32Array([
                            L/2 - x_mean, L/2 - y_mean, 0,
                            L - x_mean,   L - y_mean,   0,
                            0 - x_mean,   L - y_mean,   0
                        ]);
            geometry_B.setAttribute('position', new THREE.BufferAttribute(vertices_B, 3));
                
            var B = new THREE.Mesh( geometry_B, material_orange);

            scene.add( B );

            B.position.set(initial_position.x - offset, initial_position.y + 50, -2)

            /*Object C*/
            x_mean = 11*L/12;
            y_mean = 3*L/4;
            var geometry_C = new THREE.BufferGeometry();
            var vertices_C = new Float32Array([
                            3*L/4 - x_mean, 3*L/4 - y_mean, 0,
                            L - x_mean,     L/2 - y_mean,   0,
                            L - x_mean,     L - y_mean,     0
                        ]);
            geometry_C.setAttribute('position', new THREE.BufferAttribute(vertices_C, 3));
                
            var C = new THREE.Mesh( geometry_C, material_light_blue);

            scene.add( C );

            C.position.set(initial_position.x - offset, initial_position.y + 50, -3)

            /*Object D*/
            x_mean = 3*L/4;
            y_mean = L/2;;
            var geometry_D = new THREE.BufferGeometry();
            var vertices_D = new Float32Array([
                            L/2 - x_mean,     L/2 - y_mean,   0,
                            3*L/4 - x_mean,   L/4 - y_mean,   0,
                            L - x_mean,       L/2 - y_mean,   0,

                            L - x_mean,     L/2 - y_mean,     0,
                            3*L/4 - x_mean, 3*L/4 - y_mean,   0,
                            L/2 - x_mean,   L/2 - y_mean,     0
                        ]);
            geometry_D.setAttribute('position', new THREE.BufferAttribute(vertices_D, 3));
                
            var D = new THREE.Mesh( geometry_D, material_red);

            scene.add( D );

            D.position.set(initial_position.x - offset, initial_position.y + 50, -4)

            /*Object E*/
            x_mean = L/2;
            y_mean = L/3;;
            var geometry_E = new THREE.BufferGeometry();
            var vertices_E = new Float32Array([
                            L/4 - x_mean,     L/4 - y_mean,   0,
                            3*L/4 - x_mean,   L/4 - y_mean,   0,
                            L/2 - x_mean,   L/2 - y_mean,     0
                        ]);
            geometry_E.setAttribute('position', new THREE.BufferAttribute(vertices_E, 3));
                
            var E = new THREE.Mesh( geometry_E, material_green);

            scene.add( E );

            E.position.set(initial_position.x - offset, initial_position.y + 50, -5)

            /*Object F*/
            x_mean = 3*L/8;
            y_mean = L/8;;
            var geometry_F = new THREE.BufferGeometry();
            var vertices_F = new Float32Array([
                            0 - x_mean,     0 - y_mean,   0,
                            L/2 - x_mean,   0 - y_mean,   0,
                            3*L/4 - x_mean, L/4 - y_mean, 0,

                            3*L/4 - x_mean, L/4 - y_mean, 0,
                            L/4 - x_mean,   L/4 - y_mean, 0,
                            0 - x_mean,     0 - y_mean,   0

                        ]);
            geometry_F.setAttribute('position', new THREE.BufferAttribute(vertices_F, 3));
                
            var F = new THREE.Mesh( geometry_F, material_blue);

            scene.add( F );

            F.position.set(initial_position.x - offset, initial_position.y + 50, -6)

            /*Object G*/
            x_mean = 5*L/6;
            y_mean = L/6;
            var geometry_G = new THREE.BufferGeometry();
            var vertices_G = new Float32Array([
                            L/2 - x_mean, 0 - y_mean,   0,
                            L - x_mean,   0 - y_mean,   0,
                            L - x_mean,   L/2 - y_mean, 0


                        ]);
            geometry_G.setAttribute('position', new THREE.BufferAttribute(vertices_G, 3));
                
            var G = new THREE.Mesh( geometry_G, material_yellow);

            scene.add( G );

            G.position.set(initial_position.x - offset, initial_position.y + 50, -7)


            //-------

            var mycontrols=[A, B, C, D, E, F, G] 

            camera.position.z = 5;

            var cursor= new THREE.Mesh( new THREE.SphereGeometry(10), 
                                        new THREE.MeshBasicMaterial({color:0xdddddd}))
            cursor.position.z=-900
            scene.add(cursor)



            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2(-1000,-1000);
            var nmouse = new THREE.Vector2(-1000,-1000);


            var hover=undefined

            var pan= new THREE.Vector2(0,0)

            //Constants:
            const state = {
            FREE_CURSOR: 0,
            HOVER:       1,
            DRAG_MODE:   2,
            PAN_MODE:    3
            };

            let current_state=state.FREE_CURSOR; 
            

            //Implementação da função que retorna o polígono clipado
            //A ideia é utilizar o algoritmo de Sutherland-Hodgman
            //Descrição do algoritmo: Começa com uma lista de inputs (vértices do polígono 'subject')
            //Em seguida, um lado do polígono clipado é estendido indefinidamente em ambas as direções.
            // Os vértices do polígono original entrarão no polígono clipado se estiverem do lado 'visível' da linha estendida,
            // e novos vértices são adicionados - mais especificamente onde a linha cruza a linha estendida.
            // O processo é repetido iterativamente para cada lado do polígono
            function clip(subjectPolygon, clipPolygon) {
                var cp1, cp2, s, e;
                //Calcula se está dentro
                var inside = function (p) {
                  return (
                    (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])
                  );
                };
                //Simples interseção algébrica
                var intersection = function () {
                  var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],
                    dp = [s[0] - e[0], s[1] - e[1]],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0],
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                  return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];
                };
                var outputList = subjectPolygon;
                cp1 = clipPolygon[clipPolygon.length - 1];
                for (j in clipPolygon) {
                  var cp2 = clipPolygon[j];
                  var inputList = outputList;
                  outputList = [];
                  s = inputList[inputList.length - 1];
                  for (i in inputList) {
                    var e = inputList[i];
                    if (inside(e)) {
                      if (!inside(s)) {
                        outputList.push(intersection()); // Coloco aqui a interseção caso o ponto não esteja dentro
                      }
                      outputList.push(e);
                    } else if (inside(s)) {
                      outputList.push(intersection());
                    }
                    s = e;
                  }
                  cp1 = cp2;
                }
                return outputList;
              }
              

              //Função que calcula a área de um polígono dado seus vértices
              function AreaPolygon(vertices) {
                  var total = 0;

                  for (var i = 0, l = vertices.length; i < l; i++) {
                    var addX = vertices[i].x;
                    var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;
                    var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;
                    var subY = vertices[i].y;

                    total += (addX * addY * 0.5);
                    total -= (subX * subY * 0.5);
                  }
                  var area = total;
                  if(total < 0){
                    area = -total;
                  }
                  return area;
                }


            //Function definitions 
            function updateCursor() {
                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components
                nmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                nmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                mouse.x= event.clientX -width/2
                mouse.y= -event.clientY + height/2
                
                cursor.position.x = mouse.x -pan.x
                cursor.position.y = mouse.y -pan.y

                raycaster.setFromCamera( nmouse, camera );

            }

            var previous_material
            function onMouseMove( event ) {

                updateCursor()
                
                switch(current_state)
                {
                  case state.FREE_CURSOR: // free cursor
                    var intersects = raycaster.intersectObjects( mycontrols );
                    if (intersects.length>0)
                    {
                      current_state=state.HOVER;
                      hover=intersects[0].object;
                      previous_material = hover.material
                      hover.material=highlighted
                    }
                    break;
                
                  case state.HOVER: // hover
                    var intersects = raycaster.intersectObject( hover );
                    if (intersects.length==0)
                    {
                       hover.material=previous_material
                       current_state=state.FREE_CURSOR
                       hover=undefined
                    }
                    break;

                  case state.DRAG_MODE: // drag mode
                    hover.position.x = mouse.x -pan.x
                    hover.position.y = mouse.y -pan.y
                    break;
                    
                  case state.PAN_MODE: // pan mode
                    camera.position.x = pan.x - mouse.x
                    camera.position.y = pan.y - mouse.y
                    cursor.position.x = pan.x 
                    cursor.position.y = pan.y
                    break;
                }
                
            }


            function onMouseUp( event ) {

                updateCursor()
                
                switch(current_state)
                {
                
                  case state.DRAG_MODE: // drag mode
                    hover.position.x = mouse.x - pan.x
                    hover.position.y = mouse.y - pan.y
                    current_state=state.HOVER
                    break;
                    
                  case state.PAN_MODE: // pan mode
                    cursor.position.x = pan.x 
                    cursor.position.y = pan.y
                    pan.set(mouse.x - pan.x, mouse.y - pan.y)
                    current_state=state.FREE_CURSOR;
                    break;
                }
                
                
                
            }

            function onMouseDown( event ) {

                updateCursor()

                switch(current_state)
                {
                  case state.FREE_CURSOR: // free cursor
                    pan.set(mouse.x - pan.x, mouse.y - pan.y)
                    current_state=state.PAN_MODE;
                    break;
                
                  case state.HOVER: // hover
                    current_state = state.DRAG_MODE;
                    break;

                }
            }

            function onMouseWheel( event ) {
                event.preventDefault();
                updateCursor()

                switch(current_state)
                {

                  case state.DRAG_MODE: // drag mode
                    hover.rotateZ(event.deltaY / 2500);
                    break;

                }
            }



            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );

                }



            //This function returns the list of vertices of a geometry from a mesh.
            function getVertices( mesh ) {
                const position = mesh.geometry.getAttribute('position');
                var vertices = [];
                for ( let i = 0; i < position.count; i++ ) {
                    var vertex = new THREE.Vector3();
                    vertex.fromBufferAttribute( position, i ); 
                    mesh.localToWorld(vertex);
                    vertices.push(vertex)
                }
                return vertices
            }

            //-------

            //Call the animation loop
            window.addEventListener( 'mousemove', onMouseMove, false );
            window.addEventListener( 'mouseup', onMouseUp, false );
            window.addEventListener( 'mousedown', onMouseDown, false );
            window.addEventListener( 'wheel', onMouseWheel, false );

            animate();

		</script>
	</body>
</html>
