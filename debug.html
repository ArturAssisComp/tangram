<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Tangram</title>
		<style>
			body { margin: 0;}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
            //A scenario must have a scene, a camera, and a renderer 
            const scene = new THREE.Scene();
            width=window.innerWidth;
            height=window.innerHeight;
            const camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, -1000, 1000 );
            scene.add( camera );

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor(0xFFFFFF,1);
            document.body.appendChild( renderer.domElement );
            //-------

            //Materials and colors 
            const highlighted               = new THREE.MeshBasicMaterial( { color: 0xfff000 } );
            const material_red              = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
            const material_blue             = new THREE.MeshBasicMaterial( { color: 0x0000fff} );
            const material_black            = new THREE.MeshBasicMaterial( { color: 0x000000 } );
            const material_green            = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
            const material_orange           = new THREE.MeshBasicMaterial( { color: 0xffa500} );
            const material_yellow           = new THREE.MeshBasicMaterial( { color: 0xffff00} );
            const material_light_blue       = new THREE.MeshBasicMaterial( { color: 0x00aafff} );
            const material_ligth_blue_green = new THREE.MeshBasicMaterial( { color: 0x007777 } );


            //-------

            //Creating background 
            const L = 500
            const initial_position = new THREE.Vector2(100, -250);
            
            /*Background for object A*/
            var geometry_background_A = new THREE.BufferGeometry();
            var vertices_background_A = new Float32Array([
                            0,   0,   0,
                            L/2, L/2, 0,
                            0,   L,   0,

                            0,   L,   0,
                            0, L/2,   0,
                            0,   0,   0
                        ]);
            geometry_background_A.setAttribute('position', new THREE.BufferAttribute(vertices_background_A, 3));
            geometry_background_A.name = "geometrybackground_A";

                
            var background_A = new THREE.Mesh( geometry_background_A, material_ligth_blue_green );

            scene.add( background_A );

            background_A.position.set(initial_position.x, initial_position.y, -10)

            /*Background for object B*/
            var geometry_background_B = new THREE.BufferGeometry();
            var vertices_background_B = new Float32Array([
                            L/2 , L/2 , 0,
                            L,   L,   0,
                            0,   L,   0,
                            0 ,   L ,   0,
                            L/4 , 3*L/4 , 0,
                            L/2 , L/2 , 0
                        ]);
            geometry_background_B.setAttribute('position', new THREE.BufferAttribute(vertices_background_B, 3));
            geometry_background_B.name = "geometrybackground_B";
                
            var background_B = new THREE.Mesh( geometry_background_B, material_orange);

            scene.add( background_B );

            background_B.position.set(initial_position.x, initial_position.y, -10)


            /*Background for object background_C*/
            var geometry_background_C = new THREE.BufferGeometry();
            var vertices_background_C = new Float32Array([
                            3*L/4 , 3*L/4 , 0,
                            L ,     L/2 ,   0,
                            L ,     L ,     0,

                            L ,     L ,     0,
                            7*L/8 , 7*L/8 , 0,
                            3*L/4 , 3*L/4 , 0
                        ]);
            geometry_background_C.setAttribute('position', new THREE.BufferAttribute(vertices_background_C, 3));
                
            geometry_background_C.name = "geometrybackground_C";
            var background_C = new THREE.Mesh( geometry_background_C, material_light_blue);

            scene.add( background_C );

            background_C.position.set(initial_position.x, initial_position.y, -10)


            /*Background for object D*/
            var geometry_background_D = new THREE.BufferGeometry();
            var vertices_background_D = new Float32Array([ L/2,     L/2,   0,
                            3*L/4,   L/4,   0,
                            L,       L/2,   0,

                            L,     L/2,     0,
                            3*L/4, 3*L/4,   0,
                            L/2,   L/2,     0
                        ]);
            geometry_background_D.setAttribute('position', new THREE.BufferAttribute(vertices_background_D, 3));
                
            geometry_background_D.name = "geometrybackground_D";
            var background_D = new THREE.Mesh( geometry_background_D, material_red);

            scene.add( background_D );

            background_D.position.set(initial_position.x, initial_position.y, -10)

            /*Background for object E*/
            var geometry_background_E = new THREE.BufferGeometry();
            var vertices_background_E = new Float32Array([
                            L/4,     L/4,   0,
                            3*L/4,   L/4,   0,
                            L/2,   L/2,     0,
                            
                            L/2,   L/2,     0,
                            3*L/8,   3*L/8,     0,
                            L/4,     L/4,   0
                        ]);
            geometry_background_E.setAttribute('position', new THREE.BufferAttribute(vertices_background_E, 3));
            geometry_background_E.name = "geometrybackground_E";
                
            var background_E = new THREE.Mesh( geometry_background_E, material_green);

            scene.add( background_E );

            background_E.position.set(initial_position.x , initial_position.y , -10)

            /*Background for Object F*/
            var geometry_background_F = new THREE.BufferGeometry();
            var vertices_background_F = new Float32Array([
                            0,     0,   0,
                            L/2,   0,   0,
                            3*L/4, L/4, 0,

                            3*L/4, L/4, 0,
                            L/4,   L/4, 0,
                            0,     0,   0

                        ]);
            geometry_background_F.setAttribute('position', new THREE.BufferAttribute(vertices_background_F, 3));
            geometry_background_F.name = "geometrybackground_F";
                
            var background_F = new THREE.Mesh( geometry_background_F, material_blue);

            scene.add( background_F );

            background_F.position.set(initial_position.x, initial_position.y, -10)

            /*Background for object G*/
            var geometry_background_G = new THREE.BufferGeometry();
            var vertices_background_G = new Float32Array([
                            L/2, 0,   0,
                            L,   0,   0,
                            L,   L/2, 0,

                            L,   L/2, 0,
                            3*L/4,   L/4, 0,
                            L/2, 0,   0
                        ]);
            geometry_background_G.setAttribute('position', new THREE.BufferAttribute(vertices_background_G, 3));
            geometry_background_G.name = "geometrybackground_G";
                
            var background_G = new THREE.Mesh( geometry_background_G, material_yellow);

            scene.add( background_G );

            background_G.position.set(initial_position.x, initial_position.y, -10)

            //-------

            //Creating scene objects
            const offset = 550
            var x_mean;
            var y_mean;

            /*Object A*/
            x_mean = L/6;
            y_mean = L/2;;
            var geometry_A = new THREE.BufferGeometry();
            var vertices_A = new Float32Array([
                            0 - x_mean,   0 - y_mean,   0,
                            L/2 - x_mean, L/2 - y_mean, 0,
                            0 - x_mean,   L - y_mean,   0,
                            
                            0 - x_mean,   L - y_mean,   0,
                            0 - x_mean,   L/2 - y_mean,   0,
                            0 - x_mean,   0 - y_mean,   0

                        ]);
            geometry_A.setAttribute('position', new THREE.BufferAttribute(vertices_A, 3));
            geometry_A.name = "geometryA";

                
            var A = new THREE.Mesh( geometry_A, material_ligth_blue_green);

            scene.add( A );

            A.position.set(initial_position.x - offset, initial_position.y + 50, -1)

            /*Object B*/
            x_mean = L/2;
            y_mean = 5*L/6;;
            var geometry_B = new THREE.BufferGeometry();
            var vertices_B = new Float32Array([
                            L/2 - x_mean, L/2 - y_mean, 0,
                            L - x_mean,   L - y_mean,   0,
                            0 - x_mean,   L - y_mean,   0,

                            0 - x_mean,   L - y_mean,   0,
                            L/4 - x_mean, 3*L/4 - y_mean, 0,
                            L/2 - x_mean, L/2 - y_mean, 0
                        ]);
            geometry_B.setAttribute('position', new THREE.BufferAttribute(vertices_B, 3));
            geometry_B.name = "geometryB";
                
            var B = new THREE.Mesh( geometry_B, material_orange);

            scene.add( B );

            B.position.set(initial_position.x - offset, initial_position.y + 50, -2)

            /*Object C*/
            x_mean = 11*L/12;
            y_mean = 3*L/4;
            var geometry_C = new THREE.BufferGeometry();
            var vertices_C = new Float32Array([
                            3*L/4 - x_mean, 3*L/4 - y_mean, 0,
                            L - x_mean,     L/2 - y_mean,   0,
                            L - x_mean,     L - y_mean,     0,

                            L - x_mean,     L - y_mean,     0,
                            7*L/8 - x_mean,     7*L/8 - y_mean,     0,
                            3*L/4 - x_mean, 3*L/4 - y_mean, 0
                        ]);
            geometry_C.setAttribute('position', new THREE.BufferAttribute(vertices_C, 3));
                
            geometry_C.name = "geometryC";
            var C = new THREE.Mesh( geometry_C, material_light_blue);

            scene.add( C );

            C.position.set(initial_position.x - offset, initial_position.y + 50, -3)

            /*Object D*/
            x_mean = 3*L/4;
            y_mean = L/2;;
            var geometry_D = new THREE.BufferGeometry();
            var vertices_D = new Float32Array([
                            L/2 - x_mean,     L/2 - y_mean,   0,
                            3*L/4 - x_mean,   L/4 - y_mean,   0,
                            L - x_mean,       L/2 - y_mean,   0,

                            L - x_mean,     L/2 - y_mean,     0,
                            3*L/4 - x_mean, 3*L/4 - y_mean,   0,
                            L/2 - x_mean,   L/2 - y_mean,     0
                        ]);
            geometry_D.setAttribute('position', new THREE.BufferAttribute(vertices_D, 3));
                
            geometry_D.name = "geometryD";
            var D = new THREE.Mesh( geometry_D, material_red);

            scene.add( D );

            D.position.set(initial_position.x - offset, initial_position.y + 50, -4)

            /*Object E*/
            x_mean = L/2;
            y_mean = L/3;;
            var geometry_E = new THREE.BufferGeometry();
            var vertices_E = new Float32Array([
                            L/4 - x_mean,     L/4 - y_mean,   0,
                            3*L/4 - x_mean,   L/4 - y_mean,   0,
                            L/2 - x_mean,   L/2 - y_mean,     0,

                            L/2 - x_mean,   L/2 - y_mean,     0,
                            3*L/8 - x_mean,   3*L/8 - y_mean,     0,
                            L/4 - x_mean,     L/4 - y_mean,   0
                        ]);
            geometry_E.setAttribute('position', new THREE.BufferAttribute(vertices_E, 3));
            geometry_E.name = "geometryE";
                
            var E = new THREE.Mesh( geometry_E, material_green);

            scene.add( E );

            E.position.set(initial_position.x - offset, initial_position.y + 50, -5)

            /*Object F*/
            x_mean = 3*L/8;
            y_mean = L/8;;
            var geometry_F = new THREE.BufferGeometry();
            var vertices_F = new Float32Array([
                            0 - x_mean,     0 - y_mean,   0,
                            L/2 - x_mean,   0 - y_mean,   0,
                            3*L/4 - x_mean, L/4 - y_mean, 0,

                            3*L/4 - x_mean, L/4 - y_mean, 0,
                            L/4 - x_mean,   L/4 - y_mean, 0,
                            0 - x_mean,     0 - y_mean,   0

                        ]);
            geometry_F.setAttribute('position', new THREE.BufferAttribute(vertices_F, 3));
            geometry_F.name = "geometryF";
                
            var F = new THREE.Mesh( geometry_F, material_blue);

            scene.add( F );

            F.position.set(initial_position.x - offset, initial_position.y + 50, -6)

            /*Object G*/
            x_mean = 5*L/6;
            y_mean = L/6;
            var geometry_G = new THREE.BufferGeometry();
            var vertices_G = new Float32Array([
                            L/2 - x_mean, 0 - y_mean,   0,
                            L - x_mean,   0 - y_mean,   0,
                            L - x_mean,   L/2 - y_mean, 0,

                            L - x_mean,   L/2 - y_mean, 0,
                            3*L/4 - x_mean,   L/4 - y_mean, 0,
                            L/2 - x_mean, 0 - y_mean,   0
                        ]);
            geometry_G.setAttribute('position', new THREE.BufferAttribute(vertices_G, 3));
            geometry_G.name = "geometryG";
                
            var G = new THREE.Mesh( geometry_G, material_yellow);

            scene.add( G );

            G.position.set(initial_position.x - offset, initial_position.y + 50, -7)


            //-------
            const objectToBackground = new Map();
            objectToBackground.set(A, [background_A, 0]);
            objectToBackground.set(B, [background_B, 0]);
            objectToBackground.set(C, [background_C, 0]);
            objectToBackground.set(D, [background_D, 0]);
            objectToBackground.set(E, [background_E, 0]);
            objectToBackground.set(F, [background_F, 0]);
            objectToBackground.set(G, [background_G, 0]);

            var mycontrols=[A, B, C, D, E, F, G] 

            camera.position.z = 5;

            var cursor= new THREE.Mesh( new THREE.SphereGeometry(10), 
                                        new THREE.MeshBasicMaterial({color:0xffffff}))
            cursor.position.z=-900
            scene.add(cursor)



            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2(-1000,-1000);
            var nmouse = new THREE.Vector2(-1000,-1000);


            var hover=undefined

            var pan= new THREE.Vector2(0,0)

            const expectedTotalArea = L*L;
            const winThreshold = 95e-2;
            var remainingArea = expectedTotalArea;

            //Constants:
            const state = {
            FREE_CURSOR: 0,
            HOVER:       1,
            DRAG_MODE:   2,
            PAN_MODE:    3,
            WON:         4
            };

            let current_state=state.FREE_CURSOR; 

            //Function definitions 
            function updateCursor() {
                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components
                nmouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                nmouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                mouse.x= event.clientX -width/2
                mouse.y= -event.clientY + height/2
                
                cursor.position.x = mouse.x -pan.x
                cursor.position.y = mouse.y -pan.y

                raycaster.setFromCamera( nmouse, camera );

            }

            var previous_material
            function onMouseMove( event ) {

                updateCursor()
                
                switch(current_state)
                {
                  case state.FREE_CURSOR: // free cursor
                    var intersects = raycaster.intersectObjects( mycontrols );
                    if (intersects.length>0)
                    {
                      current_state=state.HOVER;
                      hover=intersects[0].object;
                      previous_material = hover.material
                      hover.material=highlighted
                    }
                    break;
                
                  case state.HOVER: // hover
                    var intersects = raycaster.intersectObject( hover );
                    if (intersects.length==0)
                    {
                       hover.material=previous_material
                       current_state=state.FREE_CURSOR
                       hover=undefined
                    }
                    break;

                  case state.DRAG_MODE: // drag mode
                    hover.position.x = mouse.x -pan.x
                    hover.position.y = mouse.y -pan.y
                    break;
                    
                  case state.PAN_MODE: // pan mode
                    camera.position.x = pan.x - mouse.x
                    camera.position.y = pan.y - mouse.y
                    cursor.position.x = pan.x 
                    cursor.position.y = pan.y
                    break;
                }
                
            }


            function onMouseUp( event ) {

                updateCursor()
                
                switch(current_state)
                {
                
                  case state.DRAG_MODE: // drag mode
                    hover.position.x = mouse.x - pan.x
                    hover.position.y = mouse.y - pan.y
                    //Calculate the current intersection area and update the total covered area
                    var obj = hover;
                    var backgroundObj =  objectToBackground.get(obj)[0];               
                    var clipResult = clip(getListOfVertices(obj, true), getListOfVertices(backgroundObj, true));
                    if (clipResult.length > 0) clipResult.push(clipResult[0]);
                    objectToBackground.get(obj)[1] = AreaPolygon(clipResult);
                    current_state=state.HOVER

                    //Check for winning condition:
                    remainingArea = expectedTotalArea;
                    for (i in mycontrols)
                    {
                        remainingArea -= objectToBackground.get(mycontrols[i])[1];
                    }
                    if (remainingArea / expectedTotalArea < winThreshold)
                    {
                        //Print Game Over Msg:
                        window.alert("Congratulations, you won!\nGame Over!");
                        current_state=state.WON;
                    } 
                    break;
                    
                  case state.PAN_MODE: // pan mode
                    cursor.position.x = pan.x 
                    cursor.position.y = pan.y
                    pan.set(mouse.x - pan.x, mouse.y - pan.y)
                    current_state=state.FREE_CURSOR;
                    break;
                }
                
                
                
            }

            function onMouseDown( event ) {

                updateCursor()

                switch(current_state)
                {
                  case state.FREE_CURSOR: // free cursor
                    pan.set(mouse.x - pan.x, mouse.y - pan.y)
                    current_state=state.PAN_MODE;
                    break;
                
                  case state.HOVER: // hover
                    current_state = state.DRAG_MODE;
                    break;

                }
            }

            function onMouseWheel( event ) {
                event.preventDefault();
                updateCursor()

                switch(current_state)
                {

                  case state.DRAG_MODE: // drag mode
                    hover.rotateZ(event.deltaY / 2500);
                    break;

                }
            }



            function animate() {
                requestAnimationFrame( animate );


                renderer.render( scene, camera );

                }




            //This function returns the list of vertices (Vector3()) of a geometry from a mesh.
            function getVertices( mesh ) {
                const position = mesh.geometry.getAttribute('position');
                var vertices = [];
                for ( let i = 0; i < position.count; i++ ) {
                    var vertex = new THREE.Vector3();
                    vertex.fromBufferAttribute( position, i ); 
                    mesh.localToWorld(vertex);
                    vertices.push(vertex)
                }
                return vertices
            }
            
            //This function gets the list of vertices of a mesh with the format
            // [[x1, y1], [x2, y2], ... [xn, yn]]
            //If noDuplicated is true, duplicated vertices are eliminated.
            function getListOfVertices(mesh, noDuplicated)
            {
                var vertices = getVertices(mesh);
                var verticesList = [];
                for (i in vertices)
                {
                    if(i == vertices.length-1) {break;}
                    if (noDuplicated)
                    {
                                    if(verticesList.length == 0 || (Math.abs(verticesList[verticesList.length - 1][0] - vertices[i].x) > 1e-5 || Math.abs(verticesList[verticesList.length - 1][1] - vertices[i].y) > 1e-5))
                        {
                            verticesList.push([vertices[i].x, vertices[i].y]);     
                        }
                    }
                    else 
                    {
                        verticesList.push([vertices[i].x, vertices[i].y]);        
                    }                     
                }
                return verticesList;
            }


            //Implementação da função que retorna o polígono clipado
            //A ideia é utilizar o algoritmo de Sutherland-Hodgman
            //Descrição do algoritmo: Começa com uma lista de inputs (vértices do polígono 'subject')
            //Em seguida, um lado do polígono clipado é estendido indefinidamente em ambas as direções.
            // Os vértices do polígono original entrarão no polígono clipado se estiverem do lado 'visível' da linha estendida,
            // e novos vértices são adicionados - mais especificamente onde a linha cruza a linha estendida.
            // O processo é repetido iterativamente para cada lado do polígono
            function clip(subjectPolygon, clipPolygon) {
                var cp1, cp2, s, e;
                //Calcula se está dentro
                var inside = function (p) {
                  return (
                    (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])
                  );
                };
                //Simples interseção algébrica
                var intersection = function () {
                  var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],
                    dp = [s[0] - e[0], s[1] - e[1]],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0],
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                  return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];
                };
                var outputList = subjectPolygon;
                cp1 = clipPolygon[clipPolygon.length - 1];
                for (j in clipPolygon) {
                  var cp2 = clipPolygon[j];
                  var inputList = outputList;
                  outputList = [];
                  s = inputList[inputList.length - 1];
                  for (i in inputList) {
                    var e = inputList[i];
                    if (inside(e)) {
                      if (!inside(s)) {
                        outputList.push(intersection()); // Coloco aqui a interseção caso o ponto não esteja dentro
                      }
                      outputList.push(e);
                    } else if (inside(s)) {
                      outputList.push(intersection());
                    }
                    s = e;
                  }
                  cp1 = cp2;
                }
                //Transform from [x, y] to Vector2() list:
                var vertices = [];
                for ( i in outputList ) {
                    var vertex = new THREE.Vector3();
                    vertex.x = outputList[i][0];
                    vertex.y = outputList[i][1];
                    vertices.push(vertex)
                }
                return vertices;
              }
              

              //Função que calcula a área de um polígono dado seus vértices
              function AreaPolygon(vertices) {
                  var total = 0;

                  for (var i = 0, l = vertices.length; i < l; i++) {
                    var addX = vertices[i].x;
                    var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;
                    var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;
                    var subY = vertices[i].y;

                    total += (addX * addY * 0.5);
                    total -= (subX * subY * 0.5);
                  }
                  var area = total;
                  if(total < 0){
                    area = -total;
                  }
                  return area;
                }




            //-------

            //Call the animation loop
            window.addEventListener( 'mousemove', onMouseMove, false );
            window.addEventListener( 'mouseup', onMouseUp, false );
            window.addEventListener( 'mousedown', onMouseDown, false );
            window.addEventListener( 'wheel', onMouseWheel, false );

            animate();

		</script>
	</body>
</html>
